<!DOCTYPE html>
<!-- saved from url=(0046)http://localhost:8080/agnostic_linear_adjoint/ -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc 0.10.0">
<title>agnostic_linear_adjoint API documentation</title>
<meta name="description" content="Physics-agnsotic implementation of the transfer matrix method and corresponding ajdoint problem â€¦">
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin="">
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin="">
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin="">
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>

<script defer="" src="./agnostic_linear_adjoint_docs_files/highlight.min.js.download" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin=""></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
<script type="text/javascript" async="" src="./agnostic_linear_adjoint_docs_files/MathJax.js.download"></script><style type="text/css">.MathJax_Hover_Frame {border-radius: .25em; -webkit-border-radius: .25em; -moz-border-radius: .25em; -khtml-border-radius: .25em; box-shadow: 0px 0px 15px #83A; -webkit-box-shadow: 0px 0px 15px #83A; -moz-box-shadow: 0px 0px 15px #83A; -khtml-box-shadow: 0px 0px 15px #83A; border: 1px solid #A6D ! important; display: inline-block; position: absolute}
.MathJax_Menu_Button .MathJax_Hover_Arrow {position: absolute; cursor: pointer; display: inline-block; border: 2px solid #AAA; border-radius: 4px; -webkit-border-radius: 4px; -moz-border-radius: 4px; -khtml-border-radius: 4px; font-family: 'Courier New',Courier; font-size: 9px; color: #F0F0F0}
.MathJax_Menu_Button .MathJax_Hover_Arrow span {display: block; background-color: #AAA; border: 1px solid; border-radius: 3px; line-height: 0; padding: 4px}
.MathJax_Hover_Arrow:hover {color: white!important; border: 2px solid #CCC!important}
.MathJax_Hover_Arrow:hover span {background-color: #CCC!important}
</style><style type="text/css">#MathJax_About {position: fixed; left: 50%; width: auto; text-align: center; border: 3px outset; padding: 1em 2em; background-color: #DDDDDD; color: black; cursor: default; font-family: message-box; font-size: 120%; font-style: normal; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; z-index: 201; border-radius: 15px; -webkit-border-radius: 15px; -moz-border-radius: 15px; -khtml-border-radius: 15px; box-shadow: 0px 10px 20px #808080; -webkit-box-shadow: 0px 10px 20px #808080; -moz-box-shadow: 0px 10px 20px #808080; -khtml-box-shadow: 0px 10px 20px #808080; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
#MathJax_About.MathJax_MousePost {outline: none}
.MathJax_Menu {position: absolute; background-color: white; color: black; width: auto; padding: 2px; border: 1px solid #CCCCCC; margin: 0; cursor: default; font: menu; text-align: left; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; z-index: 201; box-shadow: 0px 10px 20px #808080; -webkit-box-shadow: 0px 10px 20px #808080; -moz-box-shadow: 0px 10px 20px #808080; -khtml-box-shadow: 0px 10px 20px #808080; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
.MathJax_MenuItem {padding: 2px 2em; background: transparent}
.MathJax_MenuArrow {position: absolute; right: .5em; padding-top: .25em; color: #666666; font-size: .75em}
.MathJax_MenuActive .MathJax_MenuArrow {color: white}
.MathJax_MenuArrow.RTL {left: .5em; right: auto}
.MathJax_MenuCheck {position: absolute; left: .7em}
.MathJax_MenuCheck.RTL {right: .7em; left: auto}
.MathJax_MenuRadioCheck {position: absolute; left: 1em}
.MathJax_MenuRadioCheck.RTL {right: 1em; left: auto}
.MathJax_MenuLabel {padding: 2px 2em 4px 1.33em; font-style: italic}
.MathJax_MenuRule {border-top: 1px solid #CCCCCC; margin: 4px 1px 0px}
.MathJax_MenuDisabled {color: GrayText}
.MathJax_MenuActive {background-color: Highlight; color: HighlightText}
.MathJax_MenuDisabled:focus, .MathJax_MenuLabel:focus {background-color: #E8E8E8}
.MathJax_ContextMenu:focus {outline: none}
.MathJax_ContextMenu .MathJax_MenuItem:focus {outline: none}
#MathJax_AboutClose {top: .2em; right: .2em}
.MathJax_Menu .MathJax_MenuClose {top: -10px; left: -10px}
.MathJax_MenuClose {position: absolute; cursor: pointer; display: inline-block; border: 2px solid #AAA; border-radius: 18px; -webkit-border-radius: 18px; -moz-border-radius: 18px; -khtml-border-radius: 18px; font-family: 'Courier New',Courier; font-size: 24px; color: #F0F0F0}
.MathJax_MenuClose span {display: block; background-color: #AAA; border: 1.5px solid; border-radius: 18px; -webkit-border-radius: 18px; -moz-border-radius: 18px; -khtml-border-radius: 18px; line-height: 0; padding: 8px 0 6px}
.MathJax_MenuClose:hover {color: white!important; border: 2px solid #CCC!important}
.MathJax_MenuClose:hover span {background-color: #CCC!important}
.MathJax_MenuClose:hover:focus {outline: none}
</style><style type="text/css">.MathJax_Preview .MJXf-math {color: inherit!important}
</style><style type="text/css">.MJX_Assistive_MathML {position: absolute!important; top: 0; left: 0; clip: rect(1px, 1px, 1px, 1px); padding: 1px 0 0 0!important; border: 0!important; height: 1px!important; width: 1px!important; overflow: hidden!important; display: block!important; -webkit-touch-callout: none; -webkit-user-select: none; -khtml-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none}
.MJX_Assistive_MathML.MJX_Assistive_MathML_Block {width: 100%!important}
</style><style type="text/css">#MathJax_Zoom {position: absolute; background-color: #F0F0F0; overflow: auto; display: block; z-index: 301; padding: .5em; border: 1px solid black; margin: 0; font-weight: normal; font-style: normal; text-align: left; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; -webkit-box-sizing: content-box; -moz-box-sizing: content-box; box-sizing: content-box; box-shadow: 5px 5px 15px #AAAAAA; -webkit-box-shadow: 5px 5px 15px #AAAAAA; -moz-box-shadow: 5px 5px 15px #AAAAAA; -khtml-box-shadow: 5px 5px 15px #AAAAAA; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
#MathJax_ZoomOverlay {position: absolute; left: 0; top: 0; z-index: 300; display: inline-block; width: 100%; height: 100%; border: 0; padding: 0; margin: 0; background-color: white; opacity: 0; filter: alpha(opacity=0)}
#MathJax_ZoomFrame {position: relative; display: inline-block; height: 0; width: 0}
#MathJax_ZoomEventTrap {position: absolute; left: 0; top: 0; z-index: 302; display: inline-block; border: 0; padding: 0; margin: 0; background-color: white; opacity: 0; filter: alpha(opacity=0)}
</style><style type="text/css">.MathJax_Preview {color: #888}
#MathJax_Message {position: fixed; left: 1em; bottom: 1.5em; background-color: #E6E6E6; border: 1px solid #959595; margin: 0px; padding: 2px 8px; z-index: 102; color: black; font-size: 80%; width: auto; white-space: nowrap}
#MathJax_MSIE_Frame {position: absolute; top: 0; left: 0; width: 0px; z-index: 101; border: 0px; margin: 0px; padding: 0px}
.MathJax_Error {color: #CC0000; font-style: italic}
</style><style type="text/css">.MJXp-script {font-size: .8em}
.MJXp-right {-webkit-transform-origin: right; -moz-transform-origin: right; -ms-transform-origin: right; -o-transform-origin: right; transform-origin: right}
.MJXp-bold {font-weight: bold}
.MJXp-italic {font-style: italic}
.MJXp-scr {font-family: MathJax_Script,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-frak {font-family: MathJax_Fraktur,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-sf {font-family: MathJax_SansSerif,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-cal {font-family: MathJax_Caligraphic,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-mono {font-family: MathJax_Typewriter,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-largeop {font-size: 150%}
.MJXp-largeop.MJXp-int {vertical-align: -.2em}
.MJXp-math {display: inline-block; line-height: 1.2; text-indent: 0; font-family: 'Times New Roman',Times,STIXGeneral,serif; white-space: nowrap; border-collapse: collapse}
.MJXp-display {display: block; text-align: center; margin: 1em 0}
.MJXp-math span {display: inline-block}
.MJXp-box {display: block!important; text-align: center}
.MJXp-box:after {content: " "}
.MJXp-rule {display: block!important; margin-top: .1em}
.MJXp-char {display: block!important}
.MJXp-mo {margin: 0 .15em}
.MJXp-mfrac {margin: 0 .125em; vertical-align: .25em}
.MJXp-denom {display: inline-table!important; width: 100%}
.MJXp-denom > * {display: table-row!important}
.MJXp-surd {vertical-align: top}
.MJXp-surd > * {display: block!important}
.MJXp-script-box > *  {display: table!important; height: 50%}
.MJXp-script-box > * > * {display: table-cell!important; vertical-align: top}
.MJXp-script-box > *:last-child > * {vertical-align: bottom}
.MJXp-script-box > * > * > * {display: block!important}
.MJXp-mphantom {visibility: hidden}
.MJXp-munderover, .MJXp-munder {display: inline-table!important}
.MJXp-over {display: inline-block!important; text-align: center}
.MJXp-over > * {display: block!important}
.MJXp-munderover > *, .MJXp-munder > * {display: table-row!important}
.MJXp-mtable {vertical-align: .25em; margin: 0 .125em}
.MJXp-mtable > * {display: inline-table!important; vertical-align: middle}
.MJXp-mtr {display: table-row!important}
.MJXp-mtd {display: table-cell!important; text-align: center; padding: .5em 0 0 .5em}
.MJXp-mtr > .MJXp-mtd:first-child {padding-left: 0}
.MJXp-mtr:first-child > .MJXp-mtd {padding-top: 0}
.MJXp-mlabeledtr {display: table-row!important}
.MJXp-mlabeledtr > .MJXp-mtd:first-child {padding-left: 0}
.MJXp-mlabeledtr:first-child > .MJXp-mtd {padding-top: 0}
.MJXp-merror {background-color: #FFFF88; color: #CC0000; border: 1px solid #CC0000; padding: 1px 3px; font-style: normal; font-size: 90%}
.MJXp-scale0 {-webkit-transform: scaleX(.0); -moz-transform: scaleX(.0); -ms-transform: scaleX(.0); -o-transform: scaleX(.0); transform: scaleX(.0)}
.MJXp-scale1 {-webkit-transform: scaleX(.1); -moz-transform: scaleX(.1); -ms-transform: scaleX(.1); -o-transform: scaleX(.1); transform: scaleX(.1)}
.MJXp-scale2 {-webkit-transform: scaleX(.2); -moz-transform: scaleX(.2); -ms-transform: scaleX(.2); -o-transform: scaleX(.2); transform: scaleX(.2)}
.MJXp-scale3 {-webkit-transform: scaleX(.3); -moz-transform: scaleX(.3); -ms-transform: scaleX(.3); -o-transform: scaleX(.3); transform: scaleX(.3)}
.MJXp-scale4 {-webkit-transform: scaleX(.4); -moz-transform: scaleX(.4); -ms-transform: scaleX(.4); -o-transform: scaleX(.4); transform: scaleX(.4)}
.MJXp-scale5 {-webkit-transform: scaleX(.5); -moz-transform: scaleX(.5); -ms-transform: scaleX(.5); -o-transform: scaleX(.5); transform: scaleX(.5)}
.MJXp-scale6 {-webkit-transform: scaleX(.6); -moz-transform: scaleX(.6); -ms-transform: scaleX(.6); -o-transform: scaleX(.6); transform: scaleX(.6)}
.MJXp-scale7 {-webkit-transform: scaleX(.7); -moz-transform: scaleX(.7); -ms-transform: scaleX(.7); -o-transform: scaleX(.7); transform: scaleX(.7)}
.MJXp-scale8 {-webkit-transform: scaleX(.8); -moz-transform: scaleX(.8); -ms-transform: scaleX(.8); -o-transform: scaleX(.8); transform: scaleX(.8)}
.MJXp-scale9 {-webkit-transform: scaleX(.9); -moz-transform: scaleX(.9); -ms-transform: scaleX(.9); -o-transform: scaleX(.9); transform: scaleX(.9)}
.MathJax_PHTML .noError {vertical-align: ; font-size: 90%; text-align: left; color: black; padding: 1px 3px; border: 1px solid}
</style></head>
<body><div id="MathJax_Message" style="display: none;"></div>
<main>
<article id="content">
<header>
<nav class="http-server-breadcrumbs">
<a href="http://localhost:8080/">All packages</a>
</nav>
<h1 class="title">Module <code>agnostic_linear_adjoint</code></h1>
</header>
<section id="section-intro">
<p>Physics-agnsotic implementation of the transfer matrix method and corresponding ajdoint problem.</p>
<ul>
<li><code><a title="agnostic_linear_adjoint.agnostic_linear_tmm" href="http://localhost:8080/agnostic_linear_adjoint.html#agnostic_linear_adjoint.agnostic_linear_tmm">agnostic_linear_tmm</a></code> solves an arbitrary transfer matrix problem, given the transfer matrices</li>
<li><code><a title="agnostic_linear_adjoint.agnostic_linear_adjoint" href="http://localhost:8080/agnostic_linear_adjoint.html#agnostic_linear_adjoint.agnostic_linear_adjoint">agnostic_linear_adjoint</a></code> solves an arbitrary adjoint transfer matrix problem, returning the gradient.</li>
</ul>
<p>Copyright Nathaniel Morrison, 2023</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python hljs"><span class="hljs-string">""" Physics-agnsotic implementation of the transfer matrix method and corresponding ajdoint problem.

* `agnostic_linear_tmm` solves an arbitrary transfer matrix problem, given the transfer matrices
* `agnostic_linear_adjoint` solves an arbitrary adjoint transfer matrix problem, returning the gradient.


Copyright Nathaniel Morrison, 2023
"""</span>
<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">agnostic_linear_tmm</span>:</span>
    <span class="hljs-string">"""Solves an arbitrary linear tmm problem, given the list of transfer matrices.
    
    Methods:
        `solve_e`: solves for the field distribution
    """</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span>
        <span class="hljs-string">"""Initializes instance of `angostic_linear_tmm`"""</span>
        <span class="hljs-keyword">return</span>
    
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">solve_e</span>(<span class="hljs-params">self,tms,A,B,C</span>):</span>
        <span class="hljs-string">"""Solves for the field distribution
        
        ##Arguments
        
        `tms`: Array-like of numpy arrays or compatible datatype. Array of transfer matrices ordered from leftmost layer's matrix to the rightmost layer's
            
        `A`: Numpy array or compatible datatype. Matrix, part of global boundary condition A.e0+B.eN=c, must be dimensionally compatible with e0.
            
        `B`: Numpy array or compatible datatype. Matrix, part of global boundary condition A.e0+B.eN=c, must be dimensionally compatible with eN.
            
        `c`: Numpy array or compatible datatype. Vector, part of global boundary condition A.e0+B.eN=c, must be dimensionally compatible e0, eN.
            
        Returns:
            `e`: List of numpy arrays. The list of fields, ordered from e_0 to e_N
            
        Raises:
            `LinAlgError`: Numpy raised an error when solving for e_N, likely because the boundary conditions are insufficient. Ensure that A.T^{N,0}+B is a nonsingular matrix. 
        """</span>
        e=[]
        t_full=np.identity(len(C),dtype=np.complex64)
        <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> tms:
            t_full=np.matmul(t_full,t)
        <span class="hljs-keyword">try</span>:
            e.append(np.linalg.solve(np.matmul(A,t_full)+B,C))
        <span class="hljs-keyword">except</span> np.linalg.LinAlgError:
            print(<span class="hljs-string">'The boundary conditions you entered do not have a solution, which made numpy sad. The program will now terminate'</span>)
            <span class="hljs-keyword">raise</span> np.linalg.LinAlgError
        tms.reverse()
        <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> tms:
            e.append(np.matmul(t,e[<span class="hljs-number">-1</span>]))
        e.reverse()
        tms.reverse()
        <span class="hljs-keyword">return</span> e


<span class="hljs-comment">#Computes the total gradient of an arbitary cost function via the adjoint method.</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">agnostic_linear_adjoint</span>(<span class="hljs-params">agnostic_linear_tmm</span>):</span>
    <span class="hljs-string">"""Solves an arbitrary linear adjoint tmm problem and computes the gradient, given the list of transfer matrices, their derivatives, and the derivatives of the cost function
    
    ##Subclasses
    
    `agnostic_linear_tmm`: Solves for fields given transfer matrices. Not explicitly used in this class, but let's the user just import this class for invDes and access `agnostic_linear_tmm`'s methods too.
        
    ##Attributes
    
    `ala_eadj`: List of lists of numpy arrays. The adjoint fields, such that `ala_eadj[n][j]`=e_j' for the `n`th simulation point.
        
    `ala_dLdx`: List of floats. The gradient of the cost function, such that `ala_dLdx[m]`=dL/dphi_m. The order of phi_m is proscribed by the `dLdphi` and `all_dTdphi` inputs
        
    Methods:
    
        `solve_adjoint`: Solves for the adjoint fields and gradient
    """</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span>
        self.ala_eadj=[]
        self.ala_dLdphi=[]
        self.ala_dLdx=[]
        self.ala_nonzero_dTdphis=[]
        self.ala_nonzero_dLdes=[]
        self.ala_nonzero_dLdphis=[]
        <span class="hljs-keyword">return</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">solve_adjoint</span>(<span class="hljs-params">self,all_tms,all_fields,dLdphi,all_dLde,all_dTdphi,all_global_bc,nonzero_dTdphi=[]</span>):</span>
        <span class="hljs-string">"""Solves for the adjoint fields (`ala_eadj`) and gradient (`ala_dLdx`)
        
        ##Arguments
        
        `all_tms`: Array-like of array-likes of numpy arrays or compatible datatype. The transfer matrices, such that `all_tms[n][j]`=T^{j+1,j} for the `n`th simulation point
            
        `all_fields`: Array-like of array-likes of numpy arrays or compatible datatype. The fields, as computed by e.g. `agnostic_linear_tmm`, such that `all_fields[n][j]`=e_j for the `n`th simulation point

        `dLdphi`: Array-like of complex numbers. The partial derivatives of the cost function wrt the optimization paramters, such that `dLdphi[m]`=dL/dphi_m

        `all_dLde`: Array-like of array-likes of numpy arrays or compatible datatype. The partial derivatives of the cost function wrt the fields, such that `all_dLde[n][j]`=dL/de_j for the `n`th simulation point

        `all_dTdphi`: Array-like of array-likes of array-likes of numpy arrays or compatible datatype. The partial derivatives of the transfer matrices, such that `all_dTdphi[n][m][j]`=dT^{j+1,j}/dphi_m for the `n`th simulation point

        `all_global_bc`: Array-like of array-likes of numpy arrays or compatible datatype. The global boundary conditions, such that `all_global_bc[n]`=[A,B,c] for the `n`th simulation point, where A.e_0+B.e_N=c

        `nonzero_dTdphi`: Array-like of array-likes of array-likes of ints; optional. If not empty, flags which dT^{j+1,j}/dphi_m!= 0 to reduce computation burden; `nonzero_dTdphi[n][m]`=[j_1,j_2,...] such that dT^{j_i+1,j_i}/dphi_m!= 0
                for the `n`th simulation point.It will be assumed that dT^{j_i+1,j_i}/dphi_m=0 for any j_i not in `nonzero_dTdphi[n][m]` if `len(nonzero_dTdphi)&gt;0`. If `len(nonzero_dTdphi)==0`, then it will be assumed that dT^{j_i+1,j_i}/dphi_m!= 0 
                for all j_i, `m`, and `n`.
        """</span>
        <span class="hljs-keyword">del</span> self.ala_eadj[:]
        <span class="hljs-keyword">del</span> self.ala_dLdx[:]
        self.ala_all_tms,self.ala_all_fields,self.ala_dLdphi,self.ala_all_dLde,self.ala_all_dTdphi,self.ala_all_global_bc=all_tms,all_fields,dLdphi,all_dLde,all_dTdphi,all_global_bc
        self._process_nonzeros(all_dTdphi,all_dLde,dLdphi,nonzero_dTdphi)
        self.ala_dim=len(self.ala_all_fields[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>])
        self._solve_eadj()
        self._solve_dLdx()
        <span class="hljs-keyword">return</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_process_nonzeros</span>(<span class="hljs-params">self,dTdphi,dLde,dLdphi,nonzero_dTdphi</span>):</span>
        <span class="hljs-string">"""Filters out default values of `solve_adjoint` arguments, in case the user isn't using them """</span>
        <span class="hljs-keyword">if</span> len(nonzero_dTdphi)==<span class="hljs-number">0</span>:
            <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> range(len(dTdphi)):
                self.ala_nonzero_dTdphis.append([])
                use_dtset=dTdphi[k]
                num_dTs=len(use_dtset[<span class="hljs-number">0</span>])
                <span class="hljs-keyword">for</span> phi_set <span class="hljs-keyword">in</span> use_dtset:
                    self.ala_nonzero_dTdphis[<span class="hljs-number">-1</span>].append(set(range(num_dTs)))
        <span class="hljs-keyword">elif</span> <span class="hljs-keyword">not</span> hasattr(nonzero_dTdphi[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>],<span class="hljs-string">'__iter__'</span>):
            self.ala_nonzero_dTdphis=nonzero_dTdphi*len(dTdphi)
        <span class="hljs-keyword">else</span>:
            self.ala_nonzero_dTdphis=nonzero_dTdphi
        <span class="hljs-keyword">return</span>
        
    <span class="hljs-comment">#dLdes is positive dL/de; manually add negative in this function, e.g. the user supplies the derivative, not the negation of the derivative</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_solve_eadj</span>(<span class="hljs-params">self</span>):</span>
        <span class="hljs-string">"""Solves for adjoint fields """</span>
        <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> range(len(self.ala_all_tms)):
            self.ala_eadj.append([])
            tmsr=reversed(list(self.ala_all_tms[n]))
            dLdesr=list(reversed(list(self.ala_all_dLde[n])))
            A,B,C=self.ala_all_global_bc[n]
            t_full=np.identity(self.ala_dim,dtype=np.complex64)
            Lsum=np.zeros(self.ala_dim,dtype=np.complex64)
            j=<span class="hljs-number">1</span>
            <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> tmsr:
                t_full=np.matmul(t,t_full)
                Lsum+=np.matmul(np.transpose(t_full),<span class="hljs-number">-1</span>*dLdesr[j])
                j+=<span class="hljs-number">1</span>
            Lsum+=<span class="hljs-number">-1</span>*dLdesr[<span class="hljs-number">0</span>]
            a=np.transpose(np.matmul(A,t_full)+B)
            t_full_tp=np.transpose(t_full)
            <span class="hljs-keyword">try</span>:
                self.ala_eadj[<span class="hljs-number">-1</span>].append(np.linalg.solve(a,Lsum))
            <span class="hljs-keyword">except</span> np.linalg.LinAlgError:
                print(<span class="hljs-string">'The boundary conditions you entered do not have a solution, which made numpy sad. The program will now terminate'</span>)
                <span class="hljs-keyword">raise</span> np.linalg.LinAlgError
            tms=list(self.ala_all_tms[n])
            dLdes=list(self.ala_all_dLde[n])
            self.ala_eadj[<span class="hljs-number">-1</span>].append(np.matmul(np.transpose(A),self.ala_eadj[<span class="hljs-number">-1</span>][<span class="hljs-number">-1</span>])+dLdes[<span class="hljs-number">0</span>])
            i=<span class="hljs-number">1</span>
            <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> tms[:<span class="hljs-number">-1</span>]:
                self.ala_eadj[<span class="hljs-number">-1</span>].append(dLdes[i]+np.matmul(np.transpose(t),self.ala_eadj[<span class="hljs-number">-1</span>][<span class="hljs-number">-1</span>]))
                i+=<span class="hljs-number">1</span>
        <span class="hljs-keyword">return</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_solve_dLdx</span>(<span class="hljs-params">self</span>):</span>
        <span class="hljs-string">"""Solves for gradient """</span>
        <span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> range(len(self.ala_dLdphi)):
            self.ala_dLdx.append(<span class="hljs-number">0</span>) 
        <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> range(len(self.ala_eadj)):
            eadj=self.ala_eadj[n]
            e=self.ala_all_fields[n]
            <span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> range(len(self.ala_dLdphi)):
                d_sum=<span class="hljs-number">0</span>
                dTdphi=self.ala_all_dTdphi[n][m]
                nonzero_ds=self.ala_nonzero_dTdphis[n][m]
                <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> nonzero_ds:
                    <span class="hljs-comment">#The j+1 is because technically the first term of d_sum is eadj[0]*(dAdphi*e[0]+dBdphi*e[N]), but this is assumed zero and not included in dTdphi.</span>
                    <span class="hljs-comment">#So, dTdphi[0]=dT10/dphi, and this term of d_sum is eadj[1]*dT10/dphi*e[1]</span>
                    d_sum+=np.matmul(eadj[j+<span class="hljs-number">1</span>],np.matmul(dTdphi[j],e[j+<span class="hljs-number">1</span>]))
                self.ala_dLdx[m]+=d_sum
        <span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> range(len(self.ala_dLdphi)):
            self.ala_dLdx[m]=<span class="hljs-number">2</span>*np.real(self.ala_dLdx[m])+self.ala_dLdphi[m]
        <span class="hljs-keyword">return</span></code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="agnostic_linear_adjoint.agnostic_linear_adjoint"><code class="flex name class">
<span>class <span class="ident">agnostic_linear_adjoint</span></span>
</code></dt>
<dd>
<div class="desc"><p>Solves an arbitrary linear adjoint tmm problem and computes the gradient, given the list of transfer matrices, their derivatives, and the derivatives of the cost function</p>
<h2 id="subclasses">Subclasses</h2>
<p><code><a title="agnostic_linear_adjoint.agnostic_linear_tmm" href="http://localhost:8080/agnostic_linear_adjoint.html#agnostic_linear_adjoint.agnostic_linear_tmm">agnostic_linear_tmm</a></code>: Solves for fields given transfer matrices. Not explicitly used in this class, but let's the user just import this class for invDes and access <code><a title="agnostic_linear_adjoint.agnostic_linear_tmm" href="http://localhost:8080/agnostic_linear_adjoint.html#agnostic_linear_adjoint.agnostic_linear_tmm">agnostic_linear_tmm</a></code>'s methods too.</p>
<h2 id="attributes">Attributes</h2>
<p><code>ala_eadj</code>: List of lists of numpy arrays. The adjoint fields, such that <code>ala_eadj[n][j]</code>=e_j' for the <code>n</code>th simulation point.</p>
<p><code>ala_dLdx</code>: List of floats. The gradient of the cost function, such that <code>ala_dLdx[m]</code>=dL/dphi_m. The order of phi_m is proscribed by the <code>dLdphi</code> and <code>all_dTdphi</code> inputs</p>
<h2 id="methods">Methods</h2>
<p><code>solve_adjoint</code>: Solves for the adjoint fields and gradient</p>
<p>Initializes instance of <code>angostic_linear_tmm</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">agnostic_linear_adjoint</span>(<span class="hljs-params">agnostic_linear_tmm</span>):</span>
    <span class="hljs-string">"""Solves an arbitrary linear adjoint tmm problem and computes the gradient, given the list of transfer matrices, their derivatives, and the derivatives of the cost function
    
    ##Subclasses
    
    `agnostic_linear_tmm`: Solves for fields given transfer matrices. Not explicitly used in this class, but let's the user just import this class for invDes and access `agnostic_linear_tmm`'s methods too.
        
    ##Attributes
    
    `ala_eadj`: List of lists of numpy arrays. The adjoint fields, such that `ala_eadj[n][j]`=e_j' for the `n`th simulation point.
        
    `ala_dLdx`: List of floats. The gradient of the cost function, such that `ala_dLdx[m]`=dL/dphi_m. The order of phi_m is proscribed by the `dLdphi` and `all_dTdphi` inputs
        
    Methods:
    
        `solve_adjoint`: Solves for the adjoint fields and gradient
    """</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span>
        self.ala_eadj=[]
        self.ala_dLdphi=[]
        self.ala_dLdx=[]
        self.ala_nonzero_dTdphis=[]
        self.ala_nonzero_dLdes=[]
        self.ala_nonzero_dLdphis=[]
        <span class="hljs-keyword">return</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">solve_adjoint</span>(<span class="hljs-params">self,all_tms,all_fields,dLdphi,all_dLde,all_dTdphi,all_global_bc,nonzero_dTdphi=[]</span>):</span>
        <span class="hljs-string">"""Solves for the adjoint fields (`ala_eadj`) and gradient (`ala_dLdx`)
        
        ##Arguments
        
        `all_tms`: Array-like of array-likes of numpy arrays or compatible datatype. The transfer matrices, such that `all_tms[n][j]`=T^{j+1,j} for the `n`th simulation point
            
        `all_fields`: Array-like of array-likes of numpy arrays or compatible datatype. The fields, as computed by e.g. `agnostic_linear_tmm`, such that `all_fields[n][j]`=e_j for the `n`th simulation point

        `dLdphi`: Array-like of complex numbers. The partial derivatives of the cost function wrt the optimization paramters, such that `dLdphi[m]`=dL/dphi_m

        `all_dLde`: Array-like of array-likes of numpy arrays or compatible datatype. The partial derivatives of the cost function wrt the fields, such that `all_dLde[n][j]`=dL/de_j for the `n`th simulation point

        `all_dTdphi`: Array-like of array-likes of array-likes of numpy arrays or compatible datatype. The partial derivatives of the transfer matrices, such that `all_dTdphi[n][m][j]`=dT^{j+1,j}/dphi_m for the `n`th simulation point

        `all_global_bc`: Array-like of array-likes of numpy arrays or compatible datatype. The global boundary conditions, such that `all_global_bc[n]`=[A,B,c] for the `n`th simulation point, where A.e_0+B.e_N=c

        `nonzero_dTdphi`: Array-like of array-likes of array-likes of ints; optional. If not empty, flags which dT^{j+1,j}/dphi_m!= 0 to reduce computation burden; `nonzero_dTdphi[n][m]`=[j_1,j_2,...] such that dT^{j_i+1,j_i}/dphi_m!= 0
                for the `n`th simulation point.It will be assumed that dT^{j_i+1,j_i}/dphi_m=0 for any j_i not in `nonzero_dTdphi[n][m]` if `len(nonzero_dTdphi)&gt;0`. If `len(nonzero_dTdphi)==0`, then it will be assumed that dT^{j_i+1,j_i}/dphi_m!= 0 
                for all j_i, `m`, and `n`.
        """</span>
        <span class="hljs-keyword">del</span> self.ala_eadj[:]
        <span class="hljs-keyword">del</span> self.ala_dLdx[:]
        self.ala_all_tms,self.ala_all_fields,self.ala_dLdphi,self.ala_all_dLde,self.ala_all_dTdphi,self.ala_all_global_bc=all_tms,all_fields,dLdphi,all_dLde,all_dTdphi,all_global_bc
        self._process_nonzeros(all_dTdphi,all_dLde,dLdphi,nonzero_dTdphi)
        self.ala_dim=len(self.ala_all_fields[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>])
        self._solve_eadj()
        self._solve_dLdx()
        <span class="hljs-keyword">return</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_process_nonzeros</span>(<span class="hljs-params">self,dTdphi,dLde,dLdphi,nonzero_dTdphi</span>):</span>
        <span class="hljs-string">"""Filters out default values of `solve_adjoint` arguments, in case the user isn't using them """</span>
        <span class="hljs-keyword">if</span> len(nonzero_dTdphi)==<span class="hljs-number">0</span>:
            <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> range(len(dTdphi)):
                self.ala_nonzero_dTdphis.append([])
                use_dtset=dTdphi[k]
                num_dTs=len(use_dtset[<span class="hljs-number">0</span>])
                <span class="hljs-keyword">for</span> phi_set <span class="hljs-keyword">in</span> use_dtset:
                    self.ala_nonzero_dTdphis[<span class="hljs-number">-1</span>].append(set(range(num_dTs)))
        <span class="hljs-keyword">elif</span> <span class="hljs-keyword">not</span> hasattr(nonzero_dTdphi[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>],<span class="hljs-string">'__iter__'</span>):
            self.ala_nonzero_dTdphis=nonzero_dTdphi*len(dTdphi)
        <span class="hljs-keyword">else</span>:
            self.ala_nonzero_dTdphis=nonzero_dTdphi
        <span class="hljs-keyword">return</span>
        
    <span class="hljs-comment">#dLdes is positive dL/de; manually add negative in this function, e.g. the user supplies the derivative, not the negation of the derivative</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_solve_eadj</span>(<span class="hljs-params">self</span>):</span>
        <span class="hljs-string">"""Solves for adjoint fields """</span>
        <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> range(len(self.ala_all_tms)):
            self.ala_eadj.append([])
            tmsr=reversed(list(self.ala_all_tms[n]))
            dLdesr=list(reversed(list(self.ala_all_dLde[n])))
            A,B,C=self.ala_all_global_bc[n]
            t_full=np.identity(self.ala_dim,dtype=np.complex64)
            Lsum=np.zeros(self.ala_dim,dtype=np.complex64)
            j=<span class="hljs-number">1</span>
            <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> tmsr:
                t_full=np.matmul(t,t_full)
                Lsum+=np.matmul(np.transpose(t_full),<span class="hljs-number">-1</span>*dLdesr[j])
                j+=<span class="hljs-number">1</span>
            Lsum+=<span class="hljs-number">-1</span>*dLdesr[<span class="hljs-number">0</span>]
            a=np.transpose(np.matmul(A,t_full)+B)
            t_full_tp=np.transpose(t_full)
            <span class="hljs-keyword">try</span>:
                self.ala_eadj[<span class="hljs-number">-1</span>].append(np.linalg.solve(a,Lsum))
            <span class="hljs-keyword">except</span> np.linalg.LinAlgError:
                print(<span class="hljs-string">'The boundary conditions you entered do not have a solution, which made numpy sad. The program will now terminate'</span>)
                <span class="hljs-keyword">raise</span> np.linalg.LinAlgError
            tms=list(self.ala_all_tms[n])
            dLdes=list(self.ala_all_dLde[n])
            self.ala_eadj[<span class="hljs-number">-1</span>].append(np.matmul(np.transpose(A),self.ala_eadj[<span class="hljs-number">-1</span>][<span class="hljs-number">-1</span>])+dLdes[<span class="hljs-number">0</span>])
            i=<span class="hljs-number">1</span>
            <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> tms[:<span class="hljs-number">-1</span>]:
                self.ala_eadj[<span class="hljs-number">-1</span>].append(dLdes[i]+np.matmul(np.transpose(t),self.ala_eadj[<span class="hljs-number">-1</span>][<span class="hljs-number">-1</span>]))
                i+=<span class="hljs-number">1</span>
        <span class="hljs-keyword">return</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_solve_dLdx</span>(<span class="hljs-params">self</span>):</span>
        <span class="hljs-string">"""Solves for gradient """</span>
        <span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> range(len(self.ala_dLdphi)):
            self.ala_dLdx.append(<span class="hljs-number">0</span>) 
        <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> range(len(self.ala_eadj)):
            eadj=self.ala_eadj[n]
            e=self.ala_all_fields[n]
            <span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> range(len(self.ala_dLdphi)):
                d_sum=<span class="hljs-number">0</span>
                dTdphi=self.ala_all_dTdphi[n][m]
                nonzero_ds=self.ala_nonzero_dTdphis[n][m]
                <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> nonzero_ds:
                    <span class="hljs-comment">#The j+1 is because technically the first term of d_sum is eadj[0]*(dAdphi*e[0]+dBdphi*e[N]), but this is assumed zero and not included in dTdphi.</span>
                    <span class="hljs-comment">#So, dTdphi[0]=dT10/dphi, and this term of d_sum is eadj[1]*dT10/dphi*e[1]</span>
                    d_sum+=np.matmul(eadj[j+<span class="hljs-number">1</span>],np.matmul(dTdphi[j],e[j+<span class="hljs-number">1</span>]))
                self.ala_dLdx[m]+=d_sum
        <span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> range(len(self.ala_dLdphi)):
            self.ala_dLdx[m]=<span class="hljs-number">2</span>*np.real(self.ala_dLdx[m])+self.ala_dLdphi[m]
        <span class="hljs-keyword">return</span></code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="agnostic_linear_adjoint.agnostic_linear_tmm" href="http://localhost:8080/agnostic_linear_adjoint.html#agnostic_linear_adjoint.agnostic_linear_tmm">agnostic_linear_tmm</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="agnostic_linear_adjoint.agnostic_linear_adjoint.solve_adjoint"><code class="name flex">
<span>def <span class="ident">solve_adjoint</span></span>(<span>self, all_tms, all_fields, dLdphi, all_dLde, all_dTdphi, all_global_bc, nonzero_dTdphi=[])</span>
</code></dt>
<dd>
<div class="desc"><p>Solves for the adjoint fields (<code>ala_eadj</code>) and gradient (<code>ala_dLdx</code>)</p>
<h2 id="arguments">Arguments</h2>
<p><code>all_tms</code>: Array-like of array-likes of numpy arrays or compatible datatype. The transfer matrices, such that <code>all_tms[n][j]</code>=T^{j+1,j} for the <code>n</code>th simulation point</p>
<p><code>all_fields</code>: Array-like of array-likes of numpy arrays or compatible datatype. The fields, as computed by e.g. <code><a title="agnostic_linear_adjoint.agnostic_linear_tmm" href="http://localhost:8080/agnostic_linear_adjoint.html#agnostic_linear_adjoint.agnostic_linear_tmm">agnostic_linear_tmm</a></code>, such that <code>all_fields[n][j]</code>=e_j for the <code>n</code>th simulation point</p>
<p><code>dLdphi</code>: Array-like of complex numbers. The partial derivatives of the cost function wrt the optimization paramters, such that <code>dLdphi[m]</code>=dL/dphi_m</p>
<p><code>all_dLde</code>: Array-like of array-likes of numpy arrays or compatible datatype. The partial derivatives of the cost function wrt the fields, such that <code>all_dLde[n][j]</code>=dL/de_j for the <code>n</code>th simulation point</p>
<p><code>all_dTdphi</code>: Array-like of array-likes of array-likes of numpy arrays or compatible datatype. The partial derivatives of the transfer matrices, such that <code>all_dTdphi[n][m][j]</code>=dT^{j+1,j}/dphi_m for the <code>n</code>th simulation point</p>
<p><code>all_global_bc</code>: Array-like of array-likes of numpy arrays or compatible datatype. The global boundary conditions, such that <code>all_global_bc[n]</code>=[A,B,c] for the <code>n</code>th simulation point, where A.e_0+B.e_N=c</p>
<p><code>nonzero_dTdphi</code>: Array-like of array-likes of array-likes of ints; optional. If not empty, flags which dT^{j+1,j}/dphi_m!= 0 to reduce computation burden; <code>nonzero_dTdphi[n][m]</code>=[j_1,j_2,â€¦] such that dT^{j_i+1,j_i}/dphi_m!= 0
for the <code>n</code>th simulation point.It will be assumed that dT^{j_i+1,j_i}/dphi_m=0 for any j_i not in <code>nonzero_dTdphi[n][m]</code> if <code>len(nonzero_dTdphi)&gt;0</code>. If <code>len(nonzero_dTdphi)==0</code>, then it will be assumed that dT^{j_i+1,j_i}/dphi_m!= 0
for all j_i, <code>m</code>, and <code>n</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">solve_adjoint</span>(<span class="hljs-params">self,all_tms,all_fields,dLdphi,all_dLde,all_dTdphi,all_global_bc,nonzero_dTdphi=[]</span>):</span>
    <span class="hljs-string">"""Solves for the adjoint fields (`ala_eadj`) and gradient (`ala_dLdx`)
    
    ##Arguments
    
    `all_tms`: Array-like of array-likes of numpy arrays or compatible datatype. The transfer matrices, such that `all_tms[n][j]`=T^{j+1,j} for the `n`th simulation point
        
    `all_fields`: Array-like of array-likes of numpy arrays or compatible datatype. The fields, as computed by e.g. `agnostic_linear_tmm`, such that `all_fields[n][j]`=e_j for the `n`th simulation point

    `dLdphi`: Array-like of complex numbers. The partial derivatives of the cost function wrt the optimization paramters, such that `dLdphi[m]`=dL/dphi_m

    `all_dLde`: Array-like of array-likes of numpy arrays or compatible datatype. The partial derivatives of the cost function wrt the fields, such that `all_dLde[n][j]`=dL/de_j for the `n`th simulation point

    `all_dTdphi`: Array-like of array-likes of array-likes of numpy arrays or compatible datatype. The partial derivatives of the transfer matrices, such that `all_dTdphi[n][m][j]`=dT^{j+1,j}/dphi_m for the `n`th simulation point

    `all_global_bc`: Array-like of array-likes of numpy arrays or compatible datatype. The global boundary conditions, such that `all_global_bc[n]`=[A,B,c] for the `n`th simulation point, where A.e_0+B.e_N=c

    `nonzero_dTdphi`: Array-like of array-likes of array-likes of ints; optional. If not empty, flags which dT^{j+1,j}/dphi_m!= 0 to reduce computation burden; `nonzero_dTdphi[n][m]`=[j_1,j_2,...] such that dT^{j_i+1,j_i}/dphi_m!= 0
            for the `n`th simulation point.It will be assumed that dT^{j_i+1,j_i}/dphi_m=0 for any j_i not in `nonzero_dTdphi[n][m]` if `len(nonzero_dTdphi)&gt;0`. If `len(nonzero_dTdphi)==0`, then it will be assumed that dT^{j_i+1,j_i}/dphi_m!= 0 
            for all j_i, `m`, and `n`.
    """</span>
    <span class="hljs-keyword">del</span> self.ala_eadj[:]
    <span class="hljs-keyword">del</span> self.ala_dLdx[:]
    self.ala_all_tms,self.ala_all_fields,self.ala_dLdphi,self.ala_all_dLde,self.ala_all_dTdphi,self.ala_all_global_bc=all_tms,all_fields,dLdphi,all_dLde,all_dTdphi,all_global_bc
    self._process_nonzeros(all_dTdphi,all_dLde,dLdphi,nonzero_dTdphi)
    self.ala_dim=len(self.ala_all_fields[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>])
    self._solve_eadj()
    self._solve_dLdx()
    <span class="hljs-keyword">return</span></code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="agnostic_linear_adjoint.agnostic_linear_tmm" href="http://localhost:8080/agnostic_linear_adjoint.html#agnostic_linear_adjoint.agnostic_linear_tmm">agnostic_linear_tmm</a></b></code>:
<ul class="hlist">
<li><code><a title="agnostic_linear_adjoint.agnostic_linear_tmm.solve_e" href="http://localhost:8080/agnostic_linear_adjoint.html#agnostic_linear_adjoint.agnostic_linear_tmm.solve_e">solve_e</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="agnostic_linear_adjoint.agnostic_linear_tmm"><code class="flex name class">
<span>class <span class="ident">agnostic_linear_tmm</span></span>
</code></dt>
<dd>
<div class="desc"><p>Solves an arbitrary linear tmm problem, given the list of transfer matrices.</p>
<h2 id="methods">Methods</h2>
<p><code>solve_e</code>: solves for the field distribution</p>
<p>Initializes instance of <code>angostic_linear_tmm</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">agnostic_linear_tmm</span>:</span>
    <span class="hljs-string">"""Solves an arbitrary linear tmm problem, given the list of transfer matrices.
    
    Methods:
        `solve_e`: solves for the field distribution
    """</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span>
        <span class="hljs-string">"""Initializes instance of `angostic_linear_tmm`"""</span>
        <span class="hljs-keyword">return</span>
    
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">solve_e</span>(<span class="hljs-params">self,tms,A,B,C</span>):</span>
        <span class="hljs-string">"""Solves for the field distribution
        
        ##Arguments
        
        `tms`: Array-like of numpy arrays or compatible datatype. Array of transfer matrices ordered from leftmost layer's matrix to the rightmost layer's
            
        `A`: Numpy array or compatible datatype. Matrix, part of global boundary condition A.e0+B.eN=c, must be dimensionally compatible with e0.
            
        `B`: Numpy array or compatible datatype. Matrix, part of global boundary condition A.e0+B.eN=c, must be dimensionally compatible with eN.
            
        `c`: Numpy array or compatible datatype. Vector, part of global boundary condition A.e0+B.eN=c, must be dimensionally compatible e0, eN.
            
        Returns:
            `e`: List of numpy arrays. The list of fields, ordered from e_0 to e_N
            
        Raises:
            `LinAlgError`: Numpy raised an error when solving for e_N, likely because the boundary conditions are insufficient. Ensure that A.T^{N,0}+B is a nonsingular matrix. 
        """</span>
        e=[]
        t_full=np.identity(len(C),dtype=np.complex64)
        <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> tms:
            t_full=np.matmul(t_full,t)
        <span class="hljs-keyword">try</span>:
            e.append(np.linalg.solve(np.matmul(A,t_full)+B,C))
        <span class="hljs-keyword">except</span> np.linalg.LinAlgError:
            print(<span class="hljs-string">'The boundary conditions you entered do not have a solution, which made numpy sad. The program will now terminate'</span>)
            <span class="hljs-keyword">raise</span> np.linalg.LinAlgError
        tms.reverse()
        <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> tms:
            e.append(np.matmul(t,e[<span class="hljs-number">-1</span>]))
        e.reverse()
        tms.reverse()
        <span class="hljs-keyword">return</span> e</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="agnostic_linear_adjoint.agnostic_linear_adjoint" href="http://localhost:8080/agnostic_linear_adjoint.html#agnostic_linear_adjoint.agnostic_linear_adjoint">agnostic_linear_adjoint</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="agnostic_linear_adjoint.agnostic_linear_tmm.solve_e"><code class="name flex">
<span>def <span class="ident">solve_e</span></span>(<span>self, tms, A, B, C)</span>
</code></dt>
<dd>
<div class="desc"><p>Solves for the field distribution</p>
<h2 id="arguments">Arguments</h2>
<p><code>tms</code>: Array-like of numpy arrays or compatible datatype. Array of transfer matrices ordered from leftmost layer's matrix to the rightmost layer's</p>
<p><code>A</code>: Numpy array or compatible datatype. Matrix, part of global boundary condition A.e0+B.eN=c, must be dimensionally compatible with e0.</p>
<p><code>B</code>: Numpy array or compatible datatype. Matrix, part of global boundary condition A.e0+B.eN=c, must be dimensionally compatible with eN.</p>
<p><code>c</code>: Numpy array or compatible datatype. Vector, part of global boundary condition A.e0+B.eN=c, must be dimensionally compatible e0, eN.</p>
<h2 id="returns">Returns</h2>
<p><code>e</code>: List of numpy arrays. The list of fields, ordered from e_0 to e_N</p>
<h2 id="raises">Raises</h2>
<p><code>LinAlgError</code>: Numpy raised an error when solving for e_N, likely because the boundary conditions are insufficient. Ensure that A.T^{N,0}+B is a nonsingular matrix.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">solve_e</span>(<span class="hljs-params">self,tms,A,B,C</span>):</span>
    <span class="hljs-string">"""Solves for the field distribution
    
    ##Arguments
    
    `tms`: Array-like of numpy arrays or compatible datatype. Array of transfer matrices ordered from leftmost layer's matrix to the rightmost layer's
        
    `A`: Numpy array or compatible datatype. Matrix, part of global boundary condition A.e0+B.eN=c, must be dimensionally compatible with e0.
        
    `B`: Numpy array or compatible datatype. Matrix, part of global boundary condition A.e0+B.eN=c, must be dimensionally compatible with eN.
        
    `c`: Numpy array or compatible datatype. Vector, part of global boundary condition A.e0+B.eN=c, must be dimensionally compatible e0, eN.
        
    Returns:
        `e`: List of numpy arrays. The list of fields, ordered from e_0 to e_N
        
    Raises:
        `LinAlgError`: Numpy raised an error when solving for e_N, likely because the boundary conditions are insufficient. Ensure that A.T^{N,0}+B is a nonsingular matrix. 
    """</span>
    e=[]
    t_full=np.identity(len(C),dtype=np.complex64)
    <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> tms:
        t_full=np.matmul(t_full,t)
    <span class="hljs-keyword">try</span>:
        e.append(np.linalg.solve(np.matmul(A,t_full)+B,C))
    <span class="hljs-keyword">except</span> np.linalg.LinAlgError:
        print(<span class="hljs-string">'The boundary conditions you entered do not have a solution, which made numpy sad. The program will now terminate'</span>)
        <span class="hljs-keyword">raise</span> np.linalg.LinAlgError
    tms.reverse()
    <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> tms:
        e.append(np.matmul(t,e[<span class="hljs-number">-1</span>]))
    e.reverse()
    tms.reverse()
    <span class="hljs-keyword">return</span> e</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="http://localhost:8080/agnostic_linear_adjoint/#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="agnostic_linear_adjoint.agnostic_linear_adjoint" href="http://localhost:8080/agnostic_linear_adjoint.html#agnostic_linear_adjoint.agnostic_linear_adjoint">agnostic_linear_adjoint</a></code></h4>
<ul class="">
<li><code><a title="agnostic_linear_adjoint.agnostic_linear_adjoint.solve_adjoint" href="http://localhost:8080/agnostic_linear_adjoint.html#agnostic_linear_adjoint.agnostic_linear_adjoint.solve_adjoint">solve_adjoint</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="agnostic_linear_adjoint.agnostic_linear_tmm" href="http://localhost:8080/agnostic_linear_adjoint.html#agnostic_linear_adjoint.agnostic_linear_tmm">agnostic_linear_tmm</a></code></h4>
<ul class="">
<li><code><a title="agnostic_linear_adjoint.agnostic_linear_tmm.solve_e" href="http://localhost:8080/agnostic_linear_adjoint.html#agnostic_linear_adjoint.agnostic_linear_tmm.solve_e">solve_e</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
<script>
setInterval(() =>
fetch(window.location.href, {
method: "HEAD",
cache: "no-store",
headers: {"If-None-Match": "1688584312.2960672"},
}).then(response => response.ok && window.location.reload()), 700);
</script>

</body></html>